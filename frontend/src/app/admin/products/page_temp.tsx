'use client';

import { useEffect, useState } from 'react';
import { adminFetch } from '@/lib/admin-api';
import { ApiResponse, PaginatedData, Product, Category } from '@/types';
import Button from '@/components/Button';
import Input from '@/components/Input';
import Modal from '@/components/admin/Modal';
import Image from 'next/image';

interface ProductForm {
    category_id: string;
    name: string;
    description: string;
    price: string;
    cost_price: string;
    stock: string;
    weight: string;
    image: File | null;
}

const emptyForm: ProductForm = {
    category_id: '', name: '', description: '',
    price: '', cost_price: '', stock: '', weight: '', image: null,
};

export default function AdminProductsPage() {
    const [products, setProducts] = useState<Product[]>([]);
    const [categories, setCategories] = useState<Category[]>([]);
    const [page, setPage] = useState(1);
    const [lastPage, setLastPage] = useState(1);
    const [loading, setLoading] = useState(true);
    const [modalOpen, setModalOpen] = useState(false);
    const [editId, setEditId] = useState<number | null>(null);
    const [form, setForm] = useState<ProductForm>(emptyForm);
    const [currentImageUrl, setCurrentImageUrl] = useState<string | null>(null);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState('');
    const [deleting, setDeleting] = useState<number | null>(null);

    const fetchProducts = async (p: number) => {
        setLoading(true);
        try {
            const res = await adminFetch<ApiResponse<PaginatedData<Product>>>(`/admin/products?per_page=10&page=${p}`);
            setProducts(res.data.data);
            setLastPage(res.data.last_page);
        } catch {
            setProducts([]);
        } finally {
            setLoading(false);
        }
    };

    const fetchCategories = async () => {
        try {
            const res = await adminFetch<ApiResponse<Category[]>>('/admin/categories');
            setCategories(res.data);
        } catch { /* ignore */ }
    };

    useEffect(() => {
        fetchProducts(page);
        fetchCategories();
    }, [page]);

    const handleChange = (field: keyof ProductForm, value: string | File | null) => {
        setForm((prev) => ({ ...prev, [field]: value }));
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            setForm((prev) => ({ ...prev, image: e.target.files![0] }));
        }
    };

    const openCreate = () => {
        setEditId(null);
        setForm(emptyForm);
        setCurrentImageUrl(null);
        setError('');
        setModalOpen(true);
    };

    const openEdit = (product: Product) => {
        setEditId(product.id);
        setForm({
            category_id: String(product.category_id),
            name: product.name,
            description: product.description || '',
            price: product.price,
            cost_price: product.cost_price,
            stock: String(product.stock),
            weight: String(product.weight),
            image: null, // New file is null by default
        });
        setCurrentImageUrl(product.image ? (product.image.startsWith('http') ? product.image : `${process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000/api'}/../storage/${product.image}`) : null);
        // Note: The product object from API might already have image_url if backend is updated correctly.
        // If product.image is just filename, we construct URL. Ideally backend sends full URL.
        // Let's assume Backend sends 'image' as filename, and we have 'image_url' from accessor if we fetched fresh data.
        // But the type definition for Product might not have image_url yet.
        // For now, let's rely on product.image_url if it exists, or fallback.
        const imgUrl = (product as any).image_url || product.image;
        setCurrentImageUrl(imgUrl);

        setError('');
        setModalOpen(true);
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setSaving(true);
        setError('');

        const formData = new FormData();
        formData.append('category_id', form.category_id);
        formData.append('name', form.name);
        // Slug is auto-generated by backend now or we can send validation error if missing?
        // Wait, Request validation requires 'slug'. We should probably generate it or let user edit it.
        // The original form had 'slug' field. I removed it from 'emptyForm' but maybe I should keep it.
        // Let's put slug back.
        // Re-adding slug logic.

        // Actually, let's look at the previous file content. It had slug generation.
        // I will re-implement slug field.
    };

    // ... wait, I need to rewrite the whole file properly.
    // I will return to writing the file after checking slug logic.
    return null;
}
